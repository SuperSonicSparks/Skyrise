#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in4,    Gryo,           sensorGyro)
#pragma config(Sensor, dgtl1,  SonarL,         sensorSONAR_mm)
#pragma config(Sensor, dgtl5,  skyriseR,       sensorDigitalOut)
#pragma config(Sensor, dgtl6,  skyriseL,       sensorDigitalOut)
#pragma config(Sensor, dgtl7,  SonarR,         sensorSONAR_mm)
#pragma config(Sensor, I2C_1,  leftLiftI2C,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightLiftI2C,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  rightBackI2C,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  leftBackI2C,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  leftFrontI2C,   sensorNone)
#pragma config(Sensor, I2C_6,  rightFrontI2C,  sensorNone)
#pragma config(Motor,  port2,           leftSideYCable, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port5,           frontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port6,           frontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           backRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port9,           rightSideYCable, tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"//Main competition background code...do not modify!

////////////////////////////////////////////////////////////////////////////////////
//
//            Global Constants & Variables
//
////////////////////////////////////////////////////////////////////////////////////


int correctedspeed = 0;


// LCD Screen buttons
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;



/*
AUTONOMOUS CONST
*/
const int CLAW_CLOSE = 0;
const int CLAW_OPEN = 1;

const int DIRECTION_FORWARD = 1;
const int DIRECTION_REVERSE = -1;

const int DISTANCE_TO_WALL_MM = 50; // slams into wall at 51

const int SLOPE_TOLERANCE_MM = 3; // 1 inch == 25.4 mm

const float MOTOR_POWER_FACTOR = 1.5;

const int MOTOR_POWER_MAX = 100;
const int MOTOR_POWER_MIN = 20;

const int MOTOR_POWER_RAMP_SLEEP_INTERVAL = 25; // in milliseconds

const int DISTANCE_TO_GOAL_MM = 560;

const float DISTANCE_BETWEEN_SENSORS_MM = 216.0;



/*
Autonomous PID variables
*/
// 2 inches from front of sensor to front of robot
// 8 1/8 inches from center of sensor to center of sensor
// 23 1/2 inches from wall to center of skyrise base
float SONAR_OFFSET = -999;

float SensorSlope = 0.0;


float motorPowerCorrectionPercentage = 0.0;
int currentMotorPower = 0;
int currentPosition = 0;
int direction = DIRECTION_FORWARD;

float currentError = 0.0;
float lastError = 0.0;

int currentMotorPowerLeft = 0;
int currentMotorPowerRight = 0;



/*
Autonomous variables
*/
int grabHeight = 100;
int maxHeight = 150;
int scoreHeight = 5;
int phaseOneStoppingPoint = 63; // original value: 62
int scoringLocation = DISTANCE_TO_GOAL_MM;
int maxDrivePower = 100;
int minDrivePower = 20;
bool shoveCube = true;
bool abortAuton = false;

int AUTON_STATE = 0;


int positionToStartLoweringLiftWhenDrivingForward = 280;




/*
AUTONOMOUS LCD CONSTANTS
*/
const int AUTON_MODE_DRIVE_OFF_SQUARE = 0;
const int AUTON_MODE_SKYRISE_BUILDER_RED = 1; // skyrise is to left of robot
const int AUTON_MODE_SKYRISE_BUILDER_BLUE = 2; // skyrise is to right of robot
const int AUTON_MODE_CUBE_SCORER_RED = 3;
const int AUTON_MODE_CUBE_SCORER_BLUE = 4;
const int AUTON_MODE_PROGRAMMING_SKILLS = 5;

int AUTON_MODE = AUTON_MODE_PROGRAMMING_SKILLS;




////////////////////////////////////////////////////////////////////////////////////
//
//            Pre-Autonomous Functions
//
////////////////////////////////////////////////////////////////////////////////////
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}

void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}


void pre_auton()
{
	// LCD handling here
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;

	if (false == true)
	{
		nMotorEncoder[backLeft]=0;
		nMotorEncoder[frontLeft]=0;
		nMotorEncoder[backRight]=0;
		nMotorEncoder[frontRight]=0;


		while(nLCDButtons != centerButton)
		{
			//Switch case that allows the user to choose from 4 different options
			switch(AUTON_MODE){
				case AUTON_MODE_DRIVE_OFF_SQUARE:
					//Display first choice
					displayLCDCenteredString(0, "Just Drive");
					displayLCDCenteredString(1, "<		 Enter		>");
					waitForPress();
					//Increment or decrement "count" based on button press
					if(nLCDButtons == leftButton)
					{
						waitForRelease();
						AUTON_MODE = 3;
					}
					else if(nLCDButtons == rightButton)
					{
						waitForRelease();
						AUTON_MODE++;
					}
				break;

				case AUTON_MODE_SKYRISE_BUILDER_RED:
					//Display second choice
					displayLCDCenteredString(0, "Skyrise Red");
					displayLCDCenteredString(1, "<		 Enter		>");
					waitForPress();
					//Increment or decrement "count" based on button press
					if(nLCDButtons == leftButton)
					{
						waitForRelease();
						AUTON_MODE--;
					}
					else if(nLCDButtons == rightButton)
					{
						waitForRelease();
						AUTON_MODE++;
					}
					break;

				case AUTON_MODE_SKYRISE_BUILDER_BLUE:
					//Display second choice
					displayLCDCenteredString(0, "Skyrise Blue");
					displayLCDCenteredString(1, "<		 Enter		>");
					waitForPress();
					//Increment or decrement "count" based on button press
					if(nLCDButtons == leftButton)
					{
						waitForRelease();
						AUTON_MODE--;
					}
					else if(nLCDButtons == rightButton)
					{
						waitForRelease();
						AUTON_MODE++;
					}
					break;

				case AUTON_MODE_CUBE_SCORER_RED:
					//Display third choice
					displayLCDCenteredString(0, "Cube Red");
					displayLCDCenteredString(1, "<		 Enter		>");
					waitForPress();
					//Increment or decrement "count" based on button press
					if(nLCDButtons == leftButton)
					{
						waitForRelease();
						AUTON_MODE--;
					}
					else if(nLCDButtons == rightButton)
					{
						waitForRelease();
						AUTON_MODE++;
					}
					break;

				case AUTON_MODE_CUBE_SCORER_BLUE:
					//Display third choice
					displayLCDCenteredString(0, "Cube Blue");
					displayLCDCenteredString(1, "<		 Enter		>");
					waitForPress();
					//Increment or decrement "count" based on button press
					if(nLCDButtons == leftButton)
					{
						waitForRelease();
						AUTON_MODE--;
					}
					else if(nLCDButtons == rightButton)
					{
						waitForRelease();
						AUTON_MODE++;
					}
					break;

				case AUTON_MODE_PROGRAMMING_SKILLS:
					//Display fourth choice
					displayLCDCenteredString(0, "Prog Skills");
					displayLCDCenteredString(1, "<		 Enter		>");
					waitForPress();
					//Increment or decrement "count" based on button press
					if(nLCDButtons == leftButton)
					{
						waitForRelease();
						AUTON_MODE--;
					}
					else if(nLCDButtons == rightButton)
					{
						waitForRelease();
						AUTON_MODE = 0;
					}
					break;

				default:
					AUTON_MODE = AUTON_MODE_DRIVE_OFF_SQUARE;
					break;
			}

		}

	}

}







////////////////////////////////////////////////////////////////////////////////////
//
//     Rotate
//
////////////////////////////////////////////////////////////////////////////////////
void rotate(int howmuch)
// check gryo should start at 0	 - value is turned right + value is turned left
{
	int turnpower = 100;
	int slowdownpower = 65;
	int stoppower = 5;
	int sensitivity = 30;
	int slowdownpoint = 200;
//	howmuch = howmuch + anglecorrection;
		if (SensorValue(Gryo) > howmuch + sensitivity){ // turn right to fix
//			if (abs(SensorValue(Gryo) - howmuch) < slowdownpoint){
//				turnpower = slowdownpower;
 //			}
			while (SensorValue(Gryo) > howmuch + sensitivity){ // turn right to fix

				motor[frontRight] = -turnpower;
				motor[backRight] = -turnpower;
				motor[frontLeft] = turnpower;
				motor[backLeft] = turnpower;
				if (abs(SensorValue(Gryo) - howmuch) < slowdownpoint){
					turnpower = slowdownpower;
				}
			}
			if (SensorValue(Gryo) < howmuch - sensitivity){ // over corrected turn left to fix
				while (SensorValue(Gryo) < howmuch - sensitivity){ // turn left to fix
					motor[frontRight] = (slowdownpower);
					motor[backRight] = (slowdownpower);
					motor[frontLeft] = -(slowdownpower);
					motor[backLeft] = -(slowdownpower);
				}
			}
			motor[frontRight] = stoppower;
			motor[frontLeft] = -stoppower;
			motor[backRight] = stoppower;
			motor[backLeft] = -stoppower;
			wait1Msec(50);
		}
		else if (SensorValue(Gryo) < howmuch - sensitivity){ // turn left to fix
//				if (abs(SensorValue(Gryo) - howmuch) < slowdownpoint){
//					turnpower = slowdownpower;
//				}
			while (SensorValue(Gryo) < howmuch - sensitivity){ // turn left to fix
				motor[frontRight] = turnpower;
				motor[backRight] = turnpower;
				motor[frontLeft] = -turnpower;
				motor[backLeft] = -turnpower;
				if (abs(SensorValue(Gryo) - howmuch) < slowdownpoint){
					turnpower = slowdownpower;
				}
			}
			if (SensorValue(Gryo) > howmuch + sensitivity){ // overcorrected turn right to fix
				while (SensorValue(Gryo) > howmuch + sensitivity){ // turn right to fix
					motor[frontRight] = -(slowdownpower);
					motor[backRight] = -(slowdownpower);
					motor[frontLeft] = (slowdownpower);
					motor[backLeft] = (slowdownpower);
				}
			}
			motor[frontRight] = -stoppower;
			motor[frontLeft] = stoppower;
			motor[backRight] = -stoppower;
			motor[backLeft] = stoppower;
			wait1Msec(50);
		}
		// stop all drive motors
			motor[frontRight] = 0;
			motor[backRight] = 0;
			motor[frontLeft] = 0;
			motor[backLeft] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////
//
//                   Speed Control function
//
////////////////////////////////////////////////////////////////////////////////////
void SpeedControl(int Controlerspeed)
{
	// compensates for non-linearity of control value vs speed curve
const unsigned int TrueSpeed[128] =
	{
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0, 21, 21, 21, 22, 22, 22, 23, 24, 24,
 25, 25, 25, 25, 26, 27, 27, 28, 28, 28,
 28, 29, 30, 30, 30, 31, 31, 32, 32, 32,
 33, 33, 34, 34, 35, 35, 35, 36, 36, 37,
 37, 37, 37, 38, 38, 39, 39, 39, 40, 40,
 41, 41, 42, 42, 43, 44, 44, 45, 45, 46,
 46, 47, 47, 48, 48, 49, 50, 50, 51, 52,
 52, 53, 54, 55, 56, 57, 57, 58, 59, 60,
 61, 62, 63, 64, 65, 66, 67, 67, 68, 70,
 71, 72, 72, 73, 74, 76, 77, 78, 79, 79,
 80, 81, 83, 84, 84, 86, 86, 87, 87, 88,
 88, 89, 89, 90, 90,127,127,127	};

	if (Controlerspeed == 0)
	{
		correctedspeed = 0;
	}
	else if (Controlerspeed > 0)
	{
		if (Controlerspeed > 127)
		{
			Controlerspeed = 127;
		}
		correctedspeed = TrueSpeed[Controlerspeed];
	}
	else if (Controlerspeed < 0)
	{
		if (Controlerspeed < -127)
		{
			Controlerspeed = -127;
		}
		Controlerspeed = -Controlerspeed;
		correctedspeed = -TrueSpeed[Controlerspeed];
	}
}


////////////////////////////////////////////////////////////////////////////////////
//
//                   User Control Task
//
////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	//Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
	int threshold = 40;
	int frontrightspeed = 0;
	int frontleftspeed = 0;
	int backrightspeed = 0;
	int backleftspeed = 0;
	int liftRight = 0;

	int liftLeft = 0;
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[frontRight] = 0;
	nMotorEncoder[frontLeft] = 0;
	motor[intake] = 0;

	SensorValue[skyriseL] = 0;
	SensorValue[skyriseR] = 0;
	SensorValue[Gryo]=0;
	//who wants to Loop Forever?
	while(true)
	{

	// Drive section
	/*	if(SensorValue(leftLiftI2C)<10)
		{
			motor[leftSideYCable] = -5;
			motor[rightSideYCable] = -5;
		}*/
		if(vexRT[Ch1] > 70 & vexRT[Ch4] > 70)//used to be > 100
		{
			frontrightspeed = -vexRT[Ch4];
			frontleftspeed = -vexRT[Ch4];
			backrightspeed =	vexRT[Ch4];
			backleftspeed =	vexRT[Ch4];
		}
		else if(vexRT[Ch1] < -70 & vexRT[Ch4] < -70)
		{
			frontrightspeed = -vexRT[Ch4];
			frontleftspeed = -vexRT[Ch4];
			backrightspeed =	vexRT[Ch4];
			backleftspeed =	vexRT[Ch4];
		}
		else
		{
			if(abs(vexRT[Ch3]) > threshold)
			{
				frontleftspeed = vexRT[Ch3];
				backleftspeed =	vexRT[Ch3];
			}
			else
			{
				frontleftspeed = 0;
				backleftspeed =	0;
			}

			if(abs(vexRT[Ch2]) > threshold)
			{
				frontrightspeed = vexRT[Ch2];
				backrightspeed =	vexRT[Ch2];
			}
			else
			{
				frontrightspeed = 0;
				backrightspeed =	0;
			}
		}

		//Driven Remote Control Commands
		SpeedControl(frontrightspeed);
		motor[frontRight] = correctedspeed;

		SpeedControl(frontleftspeed);
		motor[frontLeft] = correctedspeed;

		SpeedControl(backrightspeed);
		motor[backRight] = correctedspeed;

		SpeedControl(backleftspeed);
		motor[backLeft] = correctedspeed;

		//intake
		motor[intake] = vexRT[Ch2Xmtr2];

		// lift section
		liftLeft = -vexRT[Ch3Xmtr2];
		liftRight = -vexRT[Ch3Xmtr2];

		motor[leftSideYCable] = liftLeft;
		motor[rightSideYCable] = liftRight;

		//skyrise
		if(vexRT[Btn5U] == 1)
		{
			SensorValue[skyriseL] = 0;
		}
		if(vexRT[Btn5D] == 1)
		{
			SensorValue[skyriseL] = 1;
		}
		if(vexRT[Btn6D] == 1)
		{
			SensorValue[skyriseR] = 1;
		}
		if(vexRT[Btn6U] == 1)
		{
			SensorValue[skyriseR] = 0;
		}
	}
}




// FUNC.resetDriveMotorEncoders
void resetDriveMotorEncoders()
{
	SensorValue[rightFrontI2C] = 0;
	SensorValue[leftFrontI2C] = 0;
	SensorValue[rightBackI2C] = 0;
	SensorValue[leftBackI2C] = 0;
}


// FUNC.resetLiftMotorEncoders
void resetLiftMotorEncoders()
{
	SensorValue[leftLiftI2C] = 0;
	SensorValue[rightLiftI2C] = 0;
}



// FUNC.openClaws
void openClaws()
{
	SensorValue[skyriseL] = CLAW_OPEN;
	SensorValue[skyriseR] = CLAW_OPEN;
}


// FUNC.closeClaws
void closeClaws()
{
	SensorValue[skyriseL] = CLAW_CLOSE;
	SensorValue[skyriseR] = CLAW_CLOSE;
}



// FUNC.raiseLift
void raiseLift(int stopPosition, int liftPower) {

	while (abs(SensorValue[leftLiftI2C]) < stopPosition) {
		// lift the arm up
		motor[leftSideYCable] = -liftPower;   // leftLiftI2C;
		motor[rightSideYCable] = -liftPower; //rightLiftI2C;
	}

	// apply a slight bit of upward pressure to keep the lift from sagging
	liftPower = -20;

	motor[leftSideYCable] = liftPower; // leftLiftI2C;
	motor[rightSideYCable] = liftPower; // rightLiftI2C;
}



// FUNC.lowerLift
void lowerLift(int liftStopPosition, int liftPowerDown, int liftPowerHold) {
	//currentPosition = abs(SensorValue[leftLiftI2C]);

	// lower quickly at first
	if (currentPosition > liftStopPosition)
	{
		while (currentPosition > liftStopPosition) {
			// lower the arm down
			motor[leftSideYCable] = liftPowerDown; // leftLiftI2C;
			motor[rightSideYCable] = liftPowerDown;  // rightLiftI2C;

			currentPosition = abs(SensorValue[leftLiftI2C]);
		}
	}

	motor[leftSideYCable] = liftPowerHold;  // leftLiftI2C;
	motor[rightSideYCable] = liftPowerHold; // rightLiftI2C;
}


// NOTE: if SensorL > SensorR, currentError > 0
// 			SensorL < SensorR, currentError < 0
task DriveStraightPID()
{
	while (true)
	{
		wait1Msec(10);
		motorPowerCorrectionPercentage = 0;

		if (abs(SensorValue[SonarL] - SensorValue[SonarR]) >= SLOPE_TOLERANCE_MM)
		{

			currentError = ((SensorValue[SonarL] - SensorValue[SonarR] - SONAR_OFFSET) / DISTANCE_BETWEEN_SENSORS_MM);

			currentPosition = (SensorValue[SonarL] + SensorValue[SonarR]) / 2;

			motorPowerCorrectionPercentage =
			(
				(currentMotorPower * abs(currentError))
					// * (DISTANCE_TO_GOAL_MM / (DISTANCE_TO_GOAL_MM - currentPosition))
					* MOTOR_POWER_FACTOR
			) / 100;
		}
	}
}




// TODO: handle skyrise lift here?
task AutonSkyriseLift()
{

}




// TODO: task for auton timer?


// NOTE: if SensorL > SensorR, currentError > 0
// 			SensorL < SensorR, currentError < 0
void rampUpMotorsInReverse()
{
	currentMotorPower = MOTOR_POWER_MIN;

	while (currentMotorPower < MOTOR_POWER_MAX)
	{
		// SensorL > SensorR
		// robot is rotating counterclockwise
		// slow down left motors
		if (currentError > 0)
		{
			currentMotorPowerLeft = (currentMotorPower - (currentMotorPower * motorPowerCorrectionPercentage));
			currentMotorPowerLeft = (currentMotorPowerLeft < MOTOR_POWER_MIN) ? MOTOR_POWER_MIN : currentMotorPowerLeft;
			currentMotorPowerRight = currentMotorPower;
		}
		// SensorL < SensorR
		// robot is rotating clockwise
		// slow down right motors
		else if (currentError < 0)
		{
			currentMotorPowerLeft = currentMotorPower;
			currentMotorPowerRight = (currentMotorPower - (currentMotorPower * motorPowerCorrectionPercentage));
			currentMotorPowerRight = (currentMotorPowerRight < MOTOR_POWER_MIN) ? MOTOR_POWER_MIN : currentMotorPowerRight;
		}
		else
		{
			currentMotorPowerLeft = currentMotorPower;
			currentMotorPowerRight = currentMotorPower;
		}

		motor[backLeft] = -currentMotorPowerLeft;
		motor[frontLeft] = -currentMotorPowerLeft;
		motor[backRight] = -currentMotorPowerRight;
		motor[frontRight] = -currentMotorPowerRight;
		wait1Msec(10);

		currentMotorPower += 3;
		wait1Msec(MOTOR_POWER_RAMP_SLEEP_INTERVAL);
	}
}





void rampDownMotorsInReverse()
{
	while (currentMotorPower > MOTOR_POWER_MIN
		&& currentPosition < DISTANCE_TO_GOAL_MM -50)
	{
		// SensorL > SensorR
		// robot is rotating counterclockwise
		// slow down left motors
		if (currentError > 0)
		{
			currentMotorPowerLeft = (currentMotorPower - (currentMotorPower * motorPowerCorrectionPercentage));
			currentMotorPowerRight = currentMotorPower;
		}
		// SensorL < SensorR
		// robot is rotating clockwise
		// slow down right motors
		else if (currentError < 0)
		{
			currentMotorPowerLeft = currentMotorPower;
			currentMotorPowerRight = (currentMotorPower - (currentMotorPower * motorPowerCorrectionPercentage));
		}
		else
		{
			currentMotorPowerLeft = currentMotorPower;
			currentMotorPowerRight = currentMotorPower;
		}

		motor[backLeft] = -currentMotorPowerLeft;
		motor[frontLeft] = -currentMotorPowerLeft;
		motor[backRight] = -currentMotorPowerRight;
		motor[frontRight] = -currentMotorPowerRight;

		currentMotorPower -= 5;
		wait1Msec(25);
	}

	currentMotorPower = 0;
	motor[backRight] = currentMotorPower+3;
	motor[frontRight] = currentMotorPower+3;
	motor[backLeft] = currentMotorPower;
	motor[frontLeft] = currentMotorPower;
	wait1Msec(50);

	motor[backRight] = currentMotorPower+5;
	motor[frontRight] = currentMotorPower+5;
	motor[backLeft] = currentMotorPower;
	motor[frontLeft] = currentMotorPower;
	wait1Msec(25);
}




void driveInReverse()
{
	while (currentPosition < (DISTANCE_TO_GOAL_MM-250))
	{
		currentMotorPower = MOTOR_POWER_MAX;

		// SensorL > SensorR
		// robot is rotating counterclockwise
		// slow down left motors
		if (currentError > 0)
		{
			currentMotorPowerLeft = (currentMotorPower - (currentMotorPower * motorPowerCorrectionPercentage));
			currentMotorPowerRight = currentMotorPower;
		}
		// SensorL < SensorR
		// robot is rotating clockwise
		// slow down right motors
		else if (currentError < 0)
		{
			currentMotorPowerLeft = currentMotorPower;
			currentMotorPowerRight = (currentMotorPower - (currentMotorPower * motorPowerCorrectionPercentage));
		}
		else
		{
			currentMotorPowerLeft = currentMotorPower;
			currentMotorPowerRight = currentMotorPower;
		}

		motor[backLeft] = -currentMotorPowerLeft;
		motor[frontLeft] = -currentMotorPowerLeft;
		motor[backRight] = -currentMotorPowerRight;
		motor[frontRight] = -currentMotorPowerRight;
		wait1Msec(25);
	}
}





void rampUpMotorsInForward()
{
	currentMotorPower = MOTOR_POWER_MIN;

	while (currentMotorPower < MOTOR_POWER_MAX)
	{
		// SensorL > SensorR
		// robot is rotating counterclockwise
		// slow down left motors
		if (currentError > 0)
		{
			currentMotorPowerLeft = currentMotorPower;
			currentMotorPowerRight = (currentMotorPower - (currentMotorPower * motorPowerCorrectionPercentage));
		}
		// SensorL < SensorR
		// robot is rotating clockwise
		// slow down right motors
		else if (currentError < 0)
		{
			currentMotorPowerLeft = (currentMotorPower - (currentMotorPower * motorPowerCorrectionPercentage));
			currentMotorPowerRight = currentMotorPower;
		}
		else
		{
			currentMotorPowerLeft = currentMotorPower;
			currentMotorPowerRight = currentMotorPower;
		}

		motor[backLeft] = currentMotorPowerLeft;
		motor[frontLeft] = currentMotorPowerLeft;
		motor[backRight] = currentMotorPowerRight;
		motor[frontRight] = currentMotorPowerRight;

		currentMotorPower += 3;
		wait1Msec(10);
	}
}





void rampDownMotorsInForward()
{
	while (currentMotorPower > MOTOR_POWER_MIN
		&& currentPosition > DISTANCE_TO_WALL_MM)
	{
		// SensorL > SensorR
		// robot is rotating clockwise
		// slow down left motors
		if (currentError > 0)
		{
			currentMotorPowerLeft = currentMotorPower;
			currentMotorPowerRight = (currentMotorPower - (currentMotorPower * motorPowerCorrectionPercentage));
		}
		// SensorL < SensorR
		// robot is rotating counterclockwise
		// slow down right motors
		else if (currentError < 0)
		{
			currentMotorPowerLeft = (currentMotorPower - (currentMotorPower * motorPowerCorrectionPercentage));
			currentMotorPowerRight = currentMotorPower;
		}
		else
		{
			currentMotorPowerLeft = currentMotorPower;
			currentMotorPowerRight = currentMotorPower;
		}

		motor[backLeft] = currentMotorPowerLeft;
		motor[frontLeft] = currentMotorPowerLeft;
		motor[backRight] = currentMotorPowerRight;
		motor[frontRight] = currentMotorPowerRight;

		currentMotorPower -= 5;
		wait1Msec(25);
	}

	currentMotorPower = 0;
	motor[backLeft] = currentMotorPower;
	motor[frontLeft] = currentMotorPower-3;
	motor[backRight] = currentMotorPower;
	motor[frontRight] = currentMotorPower;

	wait1Msec(50);
}




void driveInForward()
{
	while (currentPosition > (DISTANCE_TO_WALL_MM + 250))
	{
		currentMotorPower = MOTOR_POWER_MAX;

		if (currentError > 0)
		{
			currentMotorPowerLeft = currentMotorPower;
			currentMotorPowerRight = (currentMotorPower - (currentMotorPower * motorPowerCorrectionPercentage));
		}
		// SensorL < SensorR
		// robot is rotating clockwise
		// slow down right motors
		else if (currentError < 0)
		{
			currentMotorPowerLeft = (currentMotorPower - (currentMotorPower * motorPowerCorrectionPercentage));
			currentMotorPowerRight = currentMotorPower;
		}
		else
		{
			currentMotorPowerLeft = currentMotorPower;
			currentMotorPowerRight = currentMotorPower;
		}

		motor[backLeft] = currentMotorPowerLeft;
		motor[frontLeft] = currentMotorPowerLeft;
		motor[backRight] = currentMotorPowerRight;
		motor[frontRight] = currentMotorPowerRight;
		wait1Msec(50);
	}
}




void driveToWall(bool rampSpeed)
{

	rampUpMotorsInForward();

	driveInForward();

	if (rampSpeed)
	{
		rampDownMotorsInForward();
	}
}




void scoreSection(bool shoveCube)
{
	//raiseLift(grabHeight, 100);

	closeClaws();

	wait1Msec(100);

	raiseLift(maxHeight, 127);

	wait1Msec(100);

	rampUpMotorsInReverse();

	driveInReverse();

	rampDownMotorsInReverse();

	wait1Msec(250);

	lowerLift(scoreHeight, 100, 20);

	openClaws();

	wait1Msec(250);

	driveToWall(true);
}





task autonomous()
{
	// set sonar sensors offsets
	// this is the adjustment for a wall that isn't exactly perpendicular
	// to the line we want to drive
	if (SONAR_OFFSET == -999)
	{
		SONAR_OFFSET = (SensorValue[SonarL] - SensorValue[SonarR]);
	}

	AUTON_STATE = -1;

	resetLiftMotorEncoders();

	if (AUTON_MODE == AUTON_MODE_SKYRISE_BUILDER_RED
		|| AUTON_MODE == AUTON_MODE_SKYRISE_BUILDER_BLUE
		|| AUTON_MODE == AUTON_MODE_PROGRAMMING_SKILLS)
	{
		startTask(DriveStraightPID);


		// raise lift to open arms, eject cube at base
		//raiseLift(200, 127);
		//wait1Msec(100);

		openClaws();

		// lower arm
		//lowerLift(5, 127, 30);

		resetLiftMotorEncoders();

		grabHeight = 85;
		maxHeight = 300;
		scoreHeight = 5;
		shoveCube = true;
		abortAuton = false;

		raiseLift(grabHeight, 127);

		// drive straight in wall
		driveToWall(false);
		wait1Msec(250);

		scoreSection(shoveCube);
		wait1Msec(500);

		//StopTask(DriveStraightPID);

		/*
		maxHeight = 260;
		scoreHeight = 240;
		phaseOneStoppingPoint = 56;
		scoringLocation = 56; // original value: 57
		shoveCube = false;
		abortAuton = false;
		scoreSection(maxHeight
			, scoreHeight
			, phaseOneStoppingPoint
			, scoringLocation
			, drivePower
			, shoveCube
			, abortAuton);


		maxHeight = 380;
		scoreHeight = 360;
		phaseOneStoppingPoint = 56;
		scoringLocation = 56; // original value: 62
		shoveCube = false;
		abortAuton = (AUTON_MODE == AUTON_MODE_SKYRISE_BUILDER);
		scoreSection(maxHeight
			, scoreHeight
			, phaseOneStoppingPoint
			, scoringLocation
			, drivePower
			, shoveCube
			, abortAuton);


		//programming skills
		if (AUTON_MODE == AUTON_MODE_PROGRAMMING_SKILLS)
		{

			maxHeight = 600;
			scoreHeight = 580;
			phaseOneStoppingPoint = 13;
			scoringLocation = 57; // original value: 62
			drivePower = 74;
			shoveCube = false;
			abortAuton = false;
			scoreSection(maxHeight
				, scoreHeight
				, phaseOneStoppingPoint
				, scoringLocation
				, drivePower
				, shoveCube
				, abortAuton);


			maxHeight = 740;
			scoreHeight = 720;
			phaseOneStoppingPoint = 13;
			scoringLocation = 57; // original value: 62
			shoveCube = false;
			abortAuton = false;
			scoreSection(maxHeight
				, scoreHeight
				, phaseOneStoppingPoint
				, scoringLocation
				, drivePower
				, shoveCube
				, abortAuton);


			maxHeight = 850;
			scoreHeight = 830;
			phaseOneStoppingPoint = 13;
			scoringLocation = 58; // original value: 58
			shoveCube = false;
			abortAuton = false;
			scoreSection(maxHeight
				, scoreHeight
				, phaseOneStoppingPoint
				, scoringLocation
				, drivePower
				, shoveCube
				, abortAuton);


			maxHeight = 1300;
			scoreHeight = 1280;
			phaseOneStoppingPoint = 13;
			scoringLocation = 63; // original value: 62
			shoveCube = false;
			abortAuton = false;
			scoreSection(maxHeight
				, scoreHeight
				, phaseOneStoppingPoint
				, scoringLocation
				, drivePower
				, shoveCube
				, abortAuton);
		}
		*/

	}
	else if (AUTON_MODE == AUTON_MODE_CUBE_SCORER_RED)
	{
		resetLiftMotorEncoders();
		raiseLift(600, 127);

		lowerLift(5, 127, 0);

		wait1Msec(250);

		motor[backLeft] = -100;
		motor[frontLeft] = -100;
		motor[backRight] = -100;
		motor[frontRight] = -100;

		wait1Msec(1000);

		motor[backLeft] = 0;
		motor[frontLeft] = 0;
		motor[backRight] = 0;
		motor[frontRight] = 0;
	}
	else if (AUTON_MODE == AUTON_MODE_DRIVE_OFF_SQUARE)
	{

		motor[backLeft] = -100;
		motor[frontLeft] = -100;
		motor[backRight] = -100;
		motor[frontRight] = -100;

		wait1Msec(500);

		motor[backLeft] = 0;
		motor[frontLeft] = 0;
		motor[backRight] = 0;
		motor[frontRight] = 0;

		raiseLift(280, 127);
		wait1Msec(100);

		openClaws();

		// lower arm
		lowerLift(5, 127, 0);
	}

}
